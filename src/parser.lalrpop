use crate::{syntax::*, lexer::*};

grammar<'input, 'ctx>(
    input: &'input str,
    ctx: &'ctx mut Ctx,
);

pub Expr : Expr = Let => <>;

Let : Expr = {
    "let" <binder:Var> "=" <e1:Boxed<Let>> "in" <e2:Boxed<Let>> => Expr::Let{binder, e1, e2},
    <res:PlusMinus> => res,
}

PlusMinus : Expr = {
    <l:Boxed<PlusMinus>> "+" <r:Boxed<Times>> => Expr::Plus(l, r),
    <l:Boxed<PlusMinus>> "-" <r:Boxed<Times>> => Expr::Minus(l, r),
    <res:Times> => res,
}

Times : Expr = {
    <l:Boxed<Times>> "*" <r:Boxed<Neg>> => Expr::Times(l, r),
    <res:Neg> => res,
}

Neg : Expr = {
    "-" <e:Boxed<Neg>> => Expr::Neg(e),
    <res: Paren> => res,
}

Paren : Expr = {
    "(" <e:Expr> ")" => e,
    <res:Num> => res,
    Var => Expr::Var(<>),
}

Num: Expr = {
    <res:F64> => Expr::Num(res),
}

Boxed<Rule>: Box<Rule> = {
    <res:Rule> => Box::new(res),
}

F64: f64 = <f:"Float"> => f.parse().unwrap();

Var: String = <v:"Variable"> => v.to_string();

extern {
    type Location = usize;

    enum Tok<'input> {
        "let" => Tok::Let,
        "in" => Tok::In,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Times,
        "(" => Tok::ParenOpen,
        ")" => Tok::ParenClose,
        "Float" => Tok::Float(<&'input str>),
        "Variable" => Tok::Variable(<&'input str>),
    }
}